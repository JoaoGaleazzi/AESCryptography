using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AESCryptography
{
    internal class AESCrytography
    {
        const int BLOCK_SIZE = 16;

        #region SBox
        private static readonly byte[] SBox = new byte[256] {
            0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,
            0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,
            0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,
            0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,
            0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,
            0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,
            0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,
            0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,
            0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,
            0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,
            0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,
            0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,
            0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,
            0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,
            0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,
            0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16
        };
        #endregion

        #region Tabelas L e E
        private static readonly byte[] L = new byte[256]
        {
            0x00,0x00,0x19,0x01,0x32,0x02,0x1A,0xC6,0x4B,0xC7,0x1B,0x68,0x33,0xEE,0xDF,0x03,
            0x64,0x04,0xE0,0x0E,0x34,0x8D,0x81,0xEF,0x4C,0x71,0x08,0xC8,0xF8,0x69,0x1C,0xC1,
            0x7D,0xC2,0x1D,0xB5,0xF9,0xB9,0x27,0x6A,0x4D,0xE4,0xA6,0x72,0x9A,0xC9,0x09,0x78,
            0x65,0x2F,0x8A,0x05,0x21,0x0F,0xE1,0x24,0x12,0xF0,0x82,0x45,0x35,0x93,0xDA,0x8E,
            0x96,0x8F,0xDB,0xBD,0x36,0xD0,0xCE,0x94,0x13,0x5C,0xD2,0xF1,0x40,0x46,0x83,0x38,
            0x66,0xDD,0xFD,0x30,0xBF,0x06,0x8B,0x62,0xB3,0x25,0xE2,0x98,0x22,0x88,0x91,0x10,
            0x7E,0x6E,0x48,0xC3,0xA3,0xB6,0x1E,0x42,0x3A,0x6B,0x28,0x54,0xFA,0x85,0x3D,0xBA,
            0x2B,0x79,0x0A,0x15,0x9B,0x9F,0x5E,0xCA,0x4E,0xD4,0xAC,0xE5,0xF3,0x73,0xA7,0x57,
            0xAF,0x58,0xA8,0x50,0xF4,0xEA,0xD6,0x74,0x4F,0xAE,0xE9,0xD5,0xE7,0xE6,0xAD,0xE8,
            0x2C,0xD7,0x75,0x7A,0xEB,0x16,0x0B,0xF5,0x59,0xCB,0x5F,0xB0,0x9C,0xA9,0x51,0xA0,
            0x7F,0x0C,0xF6,0x6F,0x17,0xC4,0x49,0xEC,0xD8,0x43,0x1F,0x2D,0xA4,0x76,0x7B,0xB7,
            0xCC,0xBB,0x3E,0x5A,0xFB,0x60,0xB1,0x86,0x3B,0x52,0xA1,0x6C,0xAA,0x55,0x29,0x9D,
            0x97,0xB2,0x87,0x90,0x61,0xBE,0xDC,0xFC,0xBC,0x95,0xCF,0xCD,0x37,0x3F,0x5B,0xD1,
            0x53,0x39,0x84,0x3C,0x41,0xA2,0x6D,0x47,0x14,0x2A,0x9E,0x5D,0x56,0xF2,0xD3,0xAB,
            0x44,0x11,0x92,0xD9,0x23,0x20,0x2E,0x89,0xB4,0x7C,0xB8,0x26,0x77,0x99,0xE3,0xA5,
            0x67,0x4A,0xED,0xDE,0xC5,0x31,0xFE,0x18,0x0D,0x63,0x8C,0x80,0xC0,0xF7,0x70,0x07
        };

        private static readonly byte[] E = new byte[256]
        {
            0x01,0x03,0x05,0x0F,0x11,0x33,0x55,0xFF,0x1A,0x2E,0x72,0x96,0xA1,0xF8,0x13,0x35,
            0x5F,0xE1,0x38,0x48,0xD8,0x73,0x95,0xA4,0xF7,0x02,0x06,0x0A,0x1E,0x22,0x66,0xAA,
            0xE5,0x34,0x5C,0xE4,0x37,0x59,0xEB,0x26,0x6A,0xBE,0xD9,0x70,0x90,0xAB,0xE6,0x31,
            0x53,0xF5,0x04,0x0C,0x14,0x3C,0x44,0xCC,0x4F,0xD1,0x68,0xB8,0xD3,0x6E,0xB2,0xCD,
            0x4C,0xD4,0x67,0xA9,0xE0,0x3B,0x4D,0xD7,0x62,0xA6,0xF1,0x08,0x18,0x28,0x78,0x88,
            0x83,0x9E,0xB9,0xD0,0x6B,0xBD,0xDC,0x7F,0x81,0x98,0xB3,0xCE,0x49,0xDB,0x76,0x9A,
            0xB5,0xC4,0x57,0xF9,0x10,0x30,0x50,0xF0,0x0B,0x1D,0x27,0x69,0xBB,0xD6,0x61,0xA3,
            0xFE,0x19,0x2B,0x7D,0x87,0x92,0xAD,0xEC,0x2F,0x71,0x93,0xAE,0xE9,0x20,0x60,0xA0,
            0xFB,0x16,0x3A,0x4E,0xD2,0x6D,0xB7,0xC2,0x5D,0xE7,0x32,0x56,0xFA,0x15,0x3F,0x41,
            0xC3,0x5E,0xE2,0x3D,0x47,0xC9,0x40,0xC0,0x5B,0xED,0x2C,0x74,0x9C,0xBF,0xDA,0x75,
            0x9F,0xBA,0xD5,0x64,0xAC,0xEF,0x2A,0x7E,0x82,0x9D,0xBC,0xDF,0x7A,0x8E,0x89,0x80,
            0x9B,0xB6,0xC1,0x58,0xE8,0x23,0x65,0xAF,0xEA,0x25,0x6F,0xB1,0xC8,0x43,0xC5,0x54,
            0xFC,0x1F,0x21,0x63,0xA5,0xF4,0x07,0x09,0x1B,0x2D,0x77,0x99,0xB0,0xCB,0x46,0xCA,
            0x45,0xCF,0x4A,0xDE,0x79,0x8B,0x86,0x91,0xA8,0xE3,0x3E,0x42,0xC6,0x51,0xF3,0x0E,
            0x12,0x36,0x5A,0xEE,0x29,0x7B,0x8D,0x8C,0x8F,0x8A,0x85,0x94,0xA7,0xF2,0x0D,0x17,
            0x39,0x4B,0xDD,0x7C,0x84,0x97,0xA2,0xFD,0x1C,0x24,0x6C,0xB4,0xC7,0x52,0xF6,0x01
        };
        #endregion

        #region Encrypt
        public byte[] Encrypt(byte[] simpleText, byte[] key)
        {
            List<byte[]> keyScheduleWords = ExpandKey(key);
            List<byte[]> blocos = DivideInBlocks(simpleText, true);
            List<byte> bytesCifrados = new List<byte>();

            foreach (byte[] bloco in blocos)
            {
                byte[] blocoCifrado = CypherBlock(bloco, keyScheduleWords);
                foreach (var byteCifrado in blocoCifrado)
                {
                    bytesCifrados.Add(byteCifrado);
                }
            }
            return bytesCifrados.ToArray();
        }

        private byte[] CypherBlock(byte[] bloco, List<byte[]> keyScheduleWords)
        {
            byte[,] state = ByteArrayToStateMatrix(bloco);

            // Round 0
            AddRoundKey(state, GetRoundKeyBytes(keyScheduleWords, 0));

            // Rounds 1–9
            for (int round = 1; round <= 9; round++)
            {
                state = SubBytes(state);
                state = ShiftRows(state);
                state = MixColumns(state);
                AddRoundKey(state, GetRoundKeyBytes(keyScheduleWords, round));
            }

            // Round final
            state = SubBytes(state);
            state = ShiftRows(state);
            AddRoundKey(state, GetRoundKeyBytes(keyScheduleWords, 10));

            return StateMatrixToByteArray(state);
        }

        #region CypherUtil
        private void AddRoundKey(byte[,] state, byte[] roundKey)
        {
            if (roundKey.Length != 16)
                throw new ArgumentException("A round key deve ter exatamente 16 bytes.");

            int index = 0;
            for (int coluna = 0; coluna < 4; coluna++)
            {
                for (int linha = 0; linha < 4; linha++)
                {
                    state[linha, coluna] ^= roundKey[index++];
                }
            }
        }

        private byte[] GetRoundKeyBytes(List<byte[]> keyScheduleWords, int round)
        {
            byte[] roundKey = new byte[16];
            int start = round * 4; // Cada round usa 4 words (4x4 bytes = 16 bytes)
            int index = 0;

            for (int i = start; i < start + 4; i++)
            {
                for (int j = 0; j < 4; j++)
                {
                    roundKey[index++] = keyScheduleWords[i][j];
                }
            }

            return roundKey;
        }

        private byte[,] SubBytes(byte[,] state)
        {
            byte[,] result = new byte[4, 4];

            for (int linha = 0; linha < 4; linha++)
            {
                for (int coluna = 0; coluna < 4; coluna++)
                {
                    result[linha, coluna] = SBox[state[linha, coluna]];
                }
            }

            return result;
        }

        private byte[,] ShiftRows(byte[,] state)
        {
            byte[,] result = new byte[4, 4];

            for (int linha = 0; linha < 4; linha++)
            {
                for (int coluna = 0; coluna < 4; coluna++)
                {
                    result[linha, coluna] = state[linha, (coluna + linha) % 4];
                }
            }

            return result;
        }

        public static byte[,] MixColumns(byte[,] state)
        {
            for (int c = 0; c < 4; c++)
            {
                byte s0 = state[0, c];
                byte s1 = state[1, c];
                byte s2 = state[2, c];
                byte s3 = state[3, c];

                state[0, c] = (byte)(GaloisMultiply(0x02, s0) ^
                                     GaloisMultiply(0x03, s1) ^
                                     s2 ^ s3);

                state[1, c] = (byte)(s0 ^
                                     GaloisMultiply(0x02, s1) ^
                                     GaloisMultiply(0x03, s2) ^
                                     s3);

                state[2, c] = (byte)(s0 ^ s1 ^
                                     GaloisMultiply(0x02, s2) ^
                                     GaloisMultiply(0x03, s3));

                state[3, c] = (byte)(GaloisMultiply(0x03, s0) ^
                                     s1 ^ s2 ^
                                     GaloisMultiply(0x02, s3));
            }
            return state;
        }

        private static byte GaloisMultiply(byte a, byte b)
        {
            if (a == 0 || b == 0)
                return 0;

            int logSum = L[a] + L[b];
            if (logSum > 255) logSum -= 255;
            return E[logSum];
        }
        #endregion

        #endregion

        #region Decrypt
        public byte[] Decrypt(byte[] encryptedText, byte[] key)
        {
            List<byte[]> keyScheduleWords = ExpandKey(key);
            List<byte[]> blocos = DivideInBlocks(encryptedText, false);

            foreach (byte[] bloco in blocos)
            {
                byte[] blocoDecifrado = DecypherBlock(bloco);
                Persistir(blocoDecifrado);
            }
            RemoveFilling();

            return [];
        }

        private byte[] DecypherBlock(byte[] bloco)
        {
            throw new NotImplementedException();
        }

        private void RemoveFilling()
        {
            throw new NotImplementedException();
        }
        #endregion

        #region Util
        private List<byte[]> DivideInBlocks(byte[] text, bool needsPadding)
        {
            List<byte[]> blocks = new List<byte[]>();

            for (int i = 0; i < text.Length; i += BLOCK_SIZE)
            {
                blocks.Add(text.Skip(i).Take(BLOCK_SIZE).ToArray());
            }

            if (needsPadding)
            {
                int rest = text.Length % BLOCK_SIZE;
                byte[] lastBlock = new byte[BLOCK_SIZE];

                if (rest != 0)
                {
                    Array.Copy(text, text.Length - rest, lastBlock, 0, rest);
                    byte paddingValue = (byte)(BLOCK_SIZE - rest);
                    for (int i = rest; i < BLOCK_SIZE; i++)
                    {
                        lastBlock[i] = (paddingValue);
                    }
                    blocks.Add(lastBlock);
                }
                else
                {
                    byte paddingValue = (byte)BLOCK_SIZE;
                    for (int i = 0; i < BLOCK_SIZE; i++)
                    {
                        lastBlock[i] = paddingValue;
                    }
                    blocks.Add(lastBlock);
                }
            }

            return blocks;
        }

        #region ExpandKey
        private List<byte[]> ExpandKey(byte[] key)
        {
            List<byte[]> words = new List<byte[]>();
            for (int i = 0; i < 16; i += 4)
            {
                words.Add(new byte[] { key[i], key[i + 1], key[i + 2], key[i + 3] });
            }

            for (int i = 4; i < 44; i++)
            {
                byte[] tempWord = (byte[])words[i - 1].Clone();

                if (i % 4 == 0)
                {
                    tempWord = RotWord(tempWord);

                    tempWord = SubWord(tempWord);

                    byte[] roundConstant = GerarRoundConstant(i / 4);

                    for (int j = 0; j < 4; j++)
                    {
                        tempWord[j] ^= roundConstant[j];
                    }
                }

                byte[] newWord = new byte[4];
                byte[] previousRoundWord = words[i - 4];

                for (int j = 0; j < 4; j++)
                {
                    newWord[j] = (byte)(previousRoundWord[j] ^ tempWord[j]);
                }

                words.Add(newWord);
            }

            return words;
        }

        private byte[] RotWord(byte[] word)
        {
            if (word == null || word.Length != 4)
                throw new ArgumentException("RotWord espera um array de 4 bytes.");

            return new byte[] { word[1], word[2], word[3], word[0] };
        }

        private byte[] SubWord(byte[] word)
        {
            if (word == null || word.Length != 4)
                throw new ArgumentException("SubWord espera um array de 4 bytes.");

            return new byte[] {
                SBox[word[0]],
                SBox[word[1]],
                SBox[word[2]],
                SBox[word[3]]
            };
        }

        private byte[] GerarRoundConstant(int roundIndex)
        {
            byte[] values = new byte[10] {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 ,0x1b, 0x36};

            return new byte[] { values[roundIndex], 0x00, 0x00, 0x00 };
        }
        #endregion

        private void Persistir(byte[] blocoCifrado)
        {
            throw new NotImplementedException();
        }

        private byte[,] ByteArrayToStateMatrix(byte[] bloco)
        {
            byte[,] state = new byte[4, 4];
            for (int i = 0; i < 4; i++)
            {
                for (int j = 0; j < 4; j++)
                {
                    state[j, i] = bloco[i * 4 + j];
                }
            }
            return state;
        }

        private static byte[] StateMatrixToByteArray(byte[,] state)
        {
            byte[] result = new byte[16];
            int index = 0;

            // AES é armazenado por colunas
            for (int c = 0; c < 4; c++)
            {
                for (int r = 0; r < 4; r++)
                {
                    result[index++] = state[r, c];
                }
            }

            return result;
        }
        #endregion
    }
}
